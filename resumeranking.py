# -*- coding: utf-8 -*-
"""ResumeRanking.ipynb

Automatically generated by Colaboratory.

Original file is located at
https://colab.research.google.com/drive/1Jo6N5Cj1t8xuigrP75bWY-RPzPJzUcHB

### Importing libraries
"""
import warnings

warnings.filterwarnings('ignore')
import pandas as pd
import numpy as np
import spacy
import re
import nltk
import pandas as pd

nltk.download('punkt')
nltk.download('stopwords')
# !python -m spacy download xx_ent_wiki_sm
# !python -m spacy download en_core_web_sm
import en_core_web_sm
import xx_ent_wiki_sm

nlp = en_core_web_sm.load()


def extract_experience(job_desc):
    """
    A method to return the minimum experience required for the job
    :param job_desc: job description
    :return: Minimum experience required for the job

    Experience Patterns:
    Regex1 = [0-9]- [0-9] years * experience<br>
    regex2 = Experience: [0-9] to/- [0-9] years<br>
    regex3 = [0-9]+ years * experience
    """

    regex1 = r'[0-9]\s*-\s*[0-9]\s*year[s]?\s*[\w\s]*\s*experience'
    regex2 = r'experience\s*[:]?\s*[0-9]*\s*[\w]*?[-]?\s*[0-9]*\s*year[s]?'
    regex3 = r'[0-9]*\+\s*year[s]?\s*[\w\s]*\s*experience'

    regexList = [regex1, regex2, regex3]

    found_regex_list = []

    for x in regexList:
        if any(re.findall(x, job_desc)):
            some_list = re.findall(x, job_desc)
            found_regex_list.append(some_list)
    exp_list = [int(char) for item in found_regex_list for i in item for char in i if char.isdigit()]
    return min(exp_list) if len(exp_list) > 0 else None


def extract_education(job_desc):
    """
    A method to return the education required for the job
    :param job_desc: job description
    :return: Education required for the job

    regex1 = Bachelor or Master's degree<br>
    regex2 = Bachelor degree<br>
    pattern = ((r'[\w]*[\'s]*\s*degree?') or (r'[\w]*[\'s]*\s*[\w]*\s*[\w]*[\'s]*\s*degree?'))
    """

    regex1 = r'[\w]*[\’s]*?[\'s]*?\s*degree?'
    regex2 = r'[\w]*[\’s]*?[\'s]*?\s*[\w]*\s*[\w]*[\'s]*\s*degree?'

    regexList = [regex1, regex2]

    found_regex_list = []

    for x in regexList:
        if any(re.findall(x, job_desc)):
            some_list = re.findall(x, job_desc)
            if len(some_list) > 0:
                found_regex_list.append(some_list)

    return set([item.strip() for sublist in found_regex_list for item in sublist])


def extract_skills(job_desc):
    """
    Method to extract the skills required for the job
    :param job_desc: Job description
    :return: skills required
    """
    # Skills database
    skills_data = './skills_names.txt'
    with open(skills_data) as f:
        SKILLS = f.read().splitlines()
    SKILLS_DB = set()
    # convert skills to lower case

    for skills in SKILLS:
        SKILLS_DB.add(skills.lower())

    # Convert a string to lowercase
    job_desc = job_desc.lower()

    stop_words = set(nltk.corpus.stopwords.words('english'))
    word_tokens = nltk.tokenize.word_tokenize(job_desc)
    filtered_tokens = [w for w in word_tokens if w not in stop_words]
    filtered_tokens = [w for w in filtered_tokens if w.isalpha()]
    bigrams_trigrams = list(map(' '.join, nltk.everygrams(filtered_tokens, 2, 3)))
    found_skills = {token for token in filtered_tokens if token.lower() in SKILLS_DB}
    found_skills_grams = {token for token in bigrams_trigrams if token.lower() in SKILLS_DB}
    found_skills.update(found_skills_grams)
    return found_skills


def getLocation(job_desc):
    """
    :param job_desc: Job descrption
    :return: Job Location
    """

    nlp = xx_ent_wiki_sm.load()

    doc = nlp(job_desc)

    location = [ent.text for ent in doc.ents if ent.label_ in ['LOC']]
    return location


def getSkillMatchPercentage(required_skills, resume_skills):
    """
    :param required_skills: skills which are required for the job
    :param resume_skills: skills of candidate
    :return: matching percetage
    """
    # required_skills = set(required_skills.replace(" ","").split(','))
    resume_skills = set(resume_skills.split(','))
    pct_match = round(len(required_skills.intersection(resume_skills)) / len(required_skills) * 100, 0)
    return pct_match


def getExperience(required_exp, experience):
    """
    :param required_exp:  Experience required for the job
    :param experience: Candidate's experience
    :return: Yes if experience criteria is matching Else No
    """
    try:
        if required_exp or required_exp.isdigit() or required_exp != "" or required_exp != " ":
            required_exp = int(required_exp)
            resume_exp = int(experience)
            if resume_exp >= required_exp:
                return resume_exp
            return 0
    except:
        return 0


def start(job_desc):
    """
    :param job_desc: Job description provided by the user
    :return: returns the data of candidates who satisfies the job description criteria
    """
    # job_desc = input()
    job_desc = job_desc.lower()
    skills = extract_skills(job_desc)
    min_experience = extract_experience(job_desc)
    education = extract_education(job_desc)
    # df = pd.read_excel('F:\Projects\Resume Ranking\Resume Ranking Data set.xlsx')
    df = pd.read_excel('./Resume Ranking Data set.xlsx')
    df.loc[df['work_experience'] == "", 'work_experience'] = 0
    df = df[df['skills'].apply(lambda x: isinstance(x, str))]
    df['skills'] = df['skills'].apply(lambda x: ','.join(x.split(' , ')))
    match_df = pd.DataFrame()
    match_df['Name'] = df['name']
    match_df['SkillsMatchPercentage'] = df['skills'].map(lambda x: getSkillMatchPercentage(skills, x))
    # match_df['EducationMatch'] = df['degree'].map(lambda x: getEducationMatchPercentage(required_education, x))
    match_df['Experience'] = df['work_experience'].map(lambda x: getExperience(min_experience, x))
    match_df.reset_index(inplace=True)

    match_df = pd.merge(df, match_df, on=match_df.Name)
    final_df = match_df.sort_values(by=['SkillsMatchPercentage'], ascending=False)
    final_df.drop('index', axis=1, inplace=True)
    final_df = final_df.loc[final_df['Experience'] > 0]
    final_df.reset_index(drop=True, inplace=True)

    #final_df.to_excel("./RankedResumes.xlsx")
    final_df.drop(['name', 'Name'], inplace=True, axis=1)
    final_df.rename(columns={'key_0': 'Name'}, inplace=True)
    final_df = final_df[['Name', 'degree', 'emails', 'phone', 'Experience']]
    final_df.columns = ['Name', 'Degree', 'Email', 'Phone Number', 'Experience']
    final_df.to_excel("./RankedResumes.xlsx")
    return final_df


start(input())
